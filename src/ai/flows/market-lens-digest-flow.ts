
'use server';
/**
 * @fileOverview A Genkit flow to generate a daily market lens digest.
 *
 * - getMarketLensDigest - A function that generates summaries and sentiment for headlines.
 * - MarketLensDigestInput - The input type for the getMarketLensDigest function.
 * - MarketLensDigestOutput - The return type for the getMarketLensDigest function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import type { TrendingHeadline } from '@/types'; // Assuming TrendingHeadline type is defined

const HeadlineSchema = z.object({
  id: z.string(),
  title: z.string(),
  source: z.string(),
  url: z.string(),
  publishedAt: z.string(),
  isGain: z.boolean().optional(),
});

const MarketLensDigestInputSchema = z.object({
  headlines: z.array(HeadlineSchema).describe('An array of trending headlines to process.'),
  region: z.string().optional().describe('Optional region to focus the digest on (e.g., India, US, Global). Currently informational.'),
});
export type MarketLensDigestInput = z.infer<typeof MarketLensDigestInputSchema>;

const DigestedHeadlineSchema = z.object({
  originalId: z.string(),
  title: z.string().describe('The original headline title.'),
  aiSummary: z.string().describe('A concise 1-sentence AI-generated summary of the headline.'),
  source: z.string(),
  publishedAt: z.string(),
  sentiment: z.enum(['Bullish', 'Bearish', 'Neutral']).describe('Sentiment derived from the headline.'),
  trendIcon: z.enum(['up', 'down']).optional().describe('Visual cue for the trend, if applicable.'),
  originalUrl: z.string(), // Changed from z.string().url()
});

const MarketLensDigestOutputSchema = z.object({
  digestedHeadlines: z.array(DigestedHeadlineSchema).describe('An array of processed headlines with summaries and sentiment.'),
  overallMarketSentiment: z.string().describe('A brief overall market sentiment based on the provided headlines (e.g., Cautiously Optimistic, Mixed).'),
});
export type MarketLensDigestOutput = z.infer<typeof MarketLensDigestOutputSchema>;


export async function getMarketLensDigest(input: MarketLensDigestInput): Promise<MarketLensDigestOutput> {
  return getMarketLensDigestFlow(input);
}

const summarizeAndAnalyzePrompt = ai.definePrompt({
  name: 'summarizeAndAnalyzeMarketHeadlines',
  input: { schema: MarketLensDigestInputSchema },
  output: { schema: MarketLensDigestOutputSchema },
  prompt: `You are a financial news analyst for MarketPulse.
Your task is to process a list of trending headlines. For each headline:
1. Provide a concise 1-sentence summary of its main point.
2. Determine its sentiment: 'Bullish', 'Bearish', or 'Neutral'. If the headline mentions a gain or positive movement, it's 'Bullish'. If it mentions a loss or negative movement, it's 'Bearish'. Otherwise, it's 'Neutral'.
3. If Bullish, set trendIcon to 'up'. If Bearish, set trendIcon to 'down'.

After processing all headlines, provide a brief 'overallMarketSentiment' (e.g., "Market shows mixed signals with some positive indicators.", "Overall sentiment appears bullish driven by key sector gains.").

Headlines to process:
{{#each headlines}}
- ID: {{id}}, Title: "{{title}}"{{#if isGain}}, Current Trend: {{isGain}}{{/if}}
{{/each}}

Respond strictly in the JSON format defined by the output schema.
The digestedHeadlines array should contain one object for each input headline.
The originalUrl, source, and publishedAt fields for each digested headline will be populated later; you do not need to generate them, but the schema requires them.
`,
});


const getMarketLensDigestFlow = ai.defineFlow(
  {
    name: 'getMarketLensDigestFlow',
    inputSchema: MarketLensDigestInputSchema,
    outputSchema: MarketLensDigestOutputSchema,
  },
  async (input) => {
    const { output } = await summarizeAndAnalyzePrompt(input);

    if (!output) {
      throw new Error('Failed to generate market lens digest.');
    }

    // Augment with original data not directly generated by AI but needed in output
    const augmentedHeadlines = output.digestedHeadlines.map(digested => {
      const original = input.headlines.find(h => h.id === digested.originalId || h.title === digested.title); // Match by ID or title as fallback
      return {
        ...digested,
        source: original?.source || 'N/A',
        publishedAt: original?.publishedAt || new Date().toISOString(),
        originalUrl: original?.url || '#',
      };
    });

    return {
      ...output,
      digestedHeadlines: augmentedHeadlines,
    };
  }
);

